\documentclass[14pt, openany]{book}
\pagestyle{plain}
\usepackage{setspace}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{extsizes}
\usepackage[english,russian]{babel}
\let\cdash=\rcdash
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{tempora}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tlatex}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    language=scala,
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=20mm,
    top=20mm,
    right=20mm,
    bottom=20mm
}
\setlist[itemize]{noitemsep, topsep=0pt}
\setstretch{1.5}

\newcommand{\tlapl}{TLA\textsuperscript{+} }

\title{Применение формальных методов при спецификации бизнес-процессов}
\author{Морковкин Василий}
\date{2022}
\setlength{\parindent}{2em}

\begin{document}
\maketitle
\chapter*{Аннотация}
\par
История отрасли информационных технологий насчитывает немало случаев масштабных нарушений работы из-за изъянов программного обеспечения. Изъяны могут нести финансовые и репутационные потери, а также ставить под угрозу безопасность персональных данных и жизнь человека. Поэтому неотъемлемой частью процесса разработки программного обсепечения является поиск ошибок и их исправление.

Ошибки могут появляться на этапах:
\begin{itemize}
  \item спецификации,
  \item написания кода.
\end{itemize}

Практика покрытия кода автоматизированными тестами помогает минимизировать ошибки этапа написания кода, хорошо описана и широко применяется в индустрии. Ошибки спецификации, однако, такими тестами не обнаруживаются. Они могут проявляться в виде нарушения инваринтов работы системы и даже противоречивости постановки задачи. О возможных противоречиях в требованиях и теоретически достижимых гарантиях любой системы лучше знать еще до начала ее разработки. 

С этой целью данная работа фокусируется на разработке, эксплуатации и анализе применимости метода спецификации бизнес-процессов. За основу берутся формальные методы к верификации. Метод должен осваиваться разработчиками за разумное время, а результат его применения оправдывать расходы на использование.


\setcounter{page}{1}
\tableofcontents
\clearpage



\chapter{Введение}
В данной главе будут введены основные понятия, сформулированы цели, приведен анализ существующих подходов и описана структура работы.

\section{Основные понятия}
В контексте данной работы введем следующие понятия.

\emph{Формальные методы} --- набор математических техник, применяемых в сфере информационных технологий для формализации рассуждений и построения систем с изученными свойствами. 

\emph{Спецификация} --- процесс разработки технического задания, которое может быть транслировано разработчиками в программный код.

\emph{Бизнес-процесс} --- упорядоченный набор действий, выполняемых людьми или машинами, результатом исполнения которых является продукт или услуга, потребляемые пользователями.

\section{Цели работы}

\begin{itemize}
  \item Исследование существующих подходов к валидации спецификаций бизнес-процессов.
  \item Разработка методики спецификации бизнес-процессов с применением формальных методов.
  \item Подготовка инструментария для использования методики в продуктовой разработке.
  \item Применение методики на практике, оценка затрат, преимуществ и ограничений.
\end{itemize}

\section{Актуальность работы}
Ошибки программного обеспечения могут угрожать жизни людей и оборачиваться значительными финансовыми убытками. К примеру, редкая ошибка конкуррентности приводила к неконтролируемому разгону машин Toyota \cite{toyota}. А из-за гонки на данных аппарат лучевой терапии Therac-25 генерировал небезопасные дозы излучения \cite{therac}.

Примеры показывают, что даже инвестиция значительного времени в тестирование продукта не позволяет убедиться в отсутствии ошибок конкурентности. Проблема усугубляется тем, что писать надежные конкурентные тесты - весьма нетривиальная задача \cite{xpConcurrent}. Более того, сам код может соответствовать спецификации, в то время как спецификация может допускать исполнения, ведущие к нежелательным последствиям. 

Дело в том, что люди разрабатывают сложные системы, где число состояний огромно. Занимаясь ручным перебором возможных исполнений легко что-то упустить. Однако, призвав на помощь опыт математиков, о системах можно рассуждать в терминах их свойств. Такие свойства можно формулировать в утверждениях вида:

\begin{itemize}
  \item ``В системе никогда не происходит событие X``,
  \item ``Если произошло X, то в конце концов произойдет и Y``, 
  \item ``Работа алгоритма завершается``, и так далее. 
\end{itemize}

Такие свойства звучат естественно и понятны людям без специальных знаний. Имея механизм проверки этих свойств, можно строить системы, дизайн которых обладает предсказуемым поведением. Подобный подход получил распространение в сфере компьютерной безопасности \cite{formalSecure} и алгоритмов распределенных систем \cite{formalAlg}. 

При разработке бизнес-процессов спецификации зачастую выглядят как текст на натуральном языке (русский, английский и т.д.). В лучшем случае, с применением нотаций вроде BPMN \cite{bpmn} и UML \cite{uml}. Проблема таких спецификаций в том, что они не делают акцент на описании и поддержки инвариантов процессов, которые описывают. На момент написания статьи автору не удалось найти фреймворка, который бы помогал в проверке дизайна на непротиворечивость и отсутствие изъянов, и в то же время был бы доступным для освоения разработчиками или системными аналитиками.
Наверняка, владелец любого продукта не отказался бы от понимания того, что в его системе произойти не может, и что непременно произойдет.
Так почему бы не попробовать формальные методы в продуктовой разработке?


\section{Анализ подходов}
Идея применения формальных методов для спецификации бизнес-процессов не нова. Существующие фреймворки берут на вооружение различные формализмы: \emph{императивный}, \emph{декларативный}, \emph{событийный} и \emph{артефактный}. 

В \emph{императивном} формализме процессы моделируются как множества \emph{задач} или \emph{активностей}, \emph{вентилей (анг. gates)}, и \emph{событий}, связанных \emph{потоками (анг. flows)} или \emph{переходами (анг. transitions)}. Каждая активность описывает единицу работы, а переходы описывают порядок между единицами работы. Императивные подходы включают в себя верификацию распространенных нотаций BPMN \cite{specBPMN}, BPEL \cite{specBPEL}, UML \cite{specUML} и YAWL \cite{specYAWL}. 

С другой стороны, \emph{декларативыный} формализм не прибегает к концепции потоков, которые определяют очередность операций. Вместо этого процесс моделируется как множество \emph{активностей} и множество \emph{ограничений} на очередность этих активностей. Любое исполнение процесса, не запрещенное этими ограничениями, считается корректным.

\emph{Событийный} формализм \cite{specEDC} - еще один подход к моделированию. Его основу составляют \emph{событийные процессные цепочки} --- направленные графы, состоящие из \emph{событий}, \emph{активностей} и \emph{вентилей}. В отличие от императивного подхода, в событийном подходе нет явного моделирования порядка операций.

Наконец, \emph{артефактный} формализм фокусируется на эволюции бизнес-сущностей и данных. Такие спецификации включают в себя понятие жизненного цикла бизнес-сущностей (артефактов), таких как данные.

Для целей работы больше подходит декларативный подход, поскольку он не привязан к конкретной нотации. Более того, его применение не требует уже готовой спецификации. Отталкиваясь от набора простых желаемых свойств, он может выступать в роли интерактивного ассистента при разработке спецификации.


\section{Структура работы}

В Главе 2 рассматриваются математеческие формализмы, пригодные для формирования декларативной методики. Поясняется выбор языка спецификаций \tlapl. Описываются его базовые конструкции и выразительные возможности.

В Главе 3 разрабатывается сама методика. Приводятся детальные примеры использования и анализ опыта реального использования в продуктовой разработке. 

В Глава 4 описывается разработка инструментария \tlapl, полезного для применения методики.

Работа завершается подведением итогов и обсуждением дальнейших путей развития.

\chapter{Выбор инструмента}
В данной главе будет произведен обзор формальных методов \emph{доказательства теорем} и \emph{проверки моделей}, а также пояснен выбор в пользу проверки моделей для целей данной работы. Затем будет обозначена необходимость и способы моделирования времени, проведено сравнение наиболее популярных инструментов проверки моделей \emph{Alloy} и \tlapl. И, наконец, описаны концепты \tlapl, которые будут использоваться в дальнейшем.

\section{Сравнение технологий}
В плеаде формальных методов ярко выделяются два похода: \emph{доказательство теорем (анг. theorem proving)} и \emph{проверка моделей (анг. model checking)}. 

В доказательстве теорем верификация устроена индуктивно, шаг за шагом: отталкиваясь от выбранной системы аксиом и правил вывода выводятся комплексные утверждения. При использовании доказательного ассистента нам доступна работа с более точными представлениями наших систем. Однако, занимаясь проблемой разрешимости (нем. Entscheidungsproblem), Алан Тьюринг показал \cite{turing}, что не может существовать завершающегося алгоритма, который бы в качестве входных данных принимал утверждение некоторого формального языка, а на выходе выдавал бы один из двух ответов: ``истина`` или ``ложь``. Следствием этого фундаментального результата является необходимость проводить доказательства вручную (за исключением ограниченного набора простых случаев), а это требует значительной экспертизы.

В подходе проверки моделей мы описываем абстрактную версию системы и можем автоматически (с помощью \emph{проверщика моделей (анг. model checker)}) проверить ее на соответствие свойствам. При этом наша модель должна быть достаточно маленькой (в терминах количества состояний), чтобы быть обработанной проверщиком за разумное время.

Поскольку нашей целью является создание методики, доступной для освоения широким кругом людей без должной математической подготовки, фундаментом методики послужит \emph{проверка моделей}.

\section{Моделирование времени}
Нам интересна проверка утверждений вида ``X всегда верно``, ``В конце концов X будет верно``, ``X верно до тех пор, пока не верно Y``, ``Если X, то в конце концов Y будет врно``. Эти утверждения строятся вокруг концепта времени. Значит, нужен способ для его моделирования. Подходящим формализмом является \emph{темпоральная логика}. Ее разновидность, \emph{линейная темпоральная логика}, как раз позволяет кодировать утверждения о будущих путях исполнения. Типичными операторами являются: 


\begin{itemize}
  \item всегда \((\Box F)\)
  \item в итоге \((\Diamond F)\)
  \item если было \(P\), то будет и \(Q\) \((P \leadsto Q)\)
\end{itemize}


Наиболее развитыми языками спецификаций с возможностями проверки моделей и рассуждения о времени с помощью линейной темпоральной логики являются \tlapl \cite{tla} и Alloy версии 6 \cite{alloy}.

На момент написания в Alloy поддержка темпоральной логики появилась недавно, не покрыта документацией и примерами использования. Поэтому, хоть Alloy и является перспективным инструментом верификации с акцентом на визуализацию, в данной работе будет использоваться \tlapl.

\section{Возможности \tlapl}
Большинство математических концептов, используемых в \tlapl, просты. Данная секция дает представление о том, как выглядит написание выражений в \tlapl. 

Зачастую языки программирования имеют свою нотацию для математических оперторов. Например, логические операторы Java (\(!, \&\&, ||\)) в математике обозначаются как (\(\neg, \lor, \land\)) и отсутствует на большинстве раскладок клавиатур. По этой причине логический операторы в \tlapl записываются как (\char`~, /\char`\\, \char`\\/). Для других математических символов используются их эквиваленты из LaTeX.

\subsection{Логика высказываний}

\tlapl строится поверх \emph{логики высказываний}. Высказывание --- это утверждение на булевых переменных, которые принимают значения True или False. К примеру, выражение 
\[A \land (B \lor \neg C)\]
означает ``A верно И (B верно ИЛИ С ложно)``, а выражение
\[A \Rightarrow B = \neg A \lor B\]
называется ``импликацией`` и эквивалентно утверждению ``либо A ложно, либо B истинно``. Равенство в логике высказываний определяется как импликация в обе стороны.

\tlapl умеет вычислять высказывания:
\begin{tla}
  Q: FALSE => FALSE
  A: TRUE
\end{tla}
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} {\FALSE} \.{\implies} {\FALSE}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\TRUE}}%
\end{tlatex}

\begin{tlatex}
\@x{\@s{8.2} Q \.{:} {\FALSE} \.{\implies} {\FALSE}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\TRUE}}%
\end{tlatex}

Например, используя генераторы множеств, можно вывести таблицу истинности для импликации:

\begin{tla}
  Q: {<<A, B, A => B>>: A,B \in BOOLEAN}
  A: {<<FALSE, FALSE, TRUE>>,
      <<FALSE, TRUE, TRUE>>,
      <<TRUE, FALSE, FALSE>>,
      <<TRUE, TRUE, TRUE>>}
\end{tla}
\begin{tlatex}
 \@x{\@s{8.2} Q \.{:} \{ {\langle} A ,\, B ,\, A \.{\implies} B {\rangle}
 \.{:} A ,\, B \.{\in} {\BOOLEAN} \}}%
 \@x{\@s{8.2} A\@s{1.69} \.{:} \{ {\langle} {\FALSE} ,\, {\FALSE} ,\, {\TRUE}
 {\rangle} ,\,}%
\@x{\@s{39.24} {\langle} {\FALSE} ,\, {\TRUE} ,\, {\TRUE} {\rangle} ,\,}%
\@x{\@s{39.24} {\langle} {\TRUE} ,\, {\FALSE} ,\, {\FALSE} {\rangle} ,\,}%
\@x{\@s{39.24} {\langle} {\TRUE} ,\, {\TRUE} ,\, {\TRUE} {\rangle} \}}%
\end{tlatex}

\subsection{Теория множеств}
Следующим важным формализмом \tlapl является \emph{теория множеств}. Несколько примеров:
\begin{itemize}
  \item \(\{1, 2\}\) - фигурные скобки в качестве конструктора,
  \item \(1..N\) - множество от 1 до N,
  \item \(x \in S\) - проверка принадлежности x множеству S,
  \item \(S  \times S\) - декартово произведение множества S с самим собой.
\end{itemize}

Множества можно фильтровать. Выражение \(\{x \in S: P(x)\}\) является множеством всех элементов \(S\), для которых истин предикат \(P(x)\):

\begin{tla}
   Q: {<<x, y>> \in {1,2} \X {3,4}: x > y}
   A: {<<1, 3>>, <<1, 4>>, <<2, 3>>, <<2, 4>>}
\end{tla}
\begin{tlatex}
 \@x{\@s{12.29} Q \.{:} \{ {\langle} x ,\, y {\rangle} \.{\in} \{ 1 ,\, 2 \}
 \.{\times} \{ 3 ,\, 4 \} \.{:} x \.{>} y \}}%
 \@x{\@s{12.29} A\@s{1.69} \.{:} \{ {\langle} 1 ,\, 3 {\rangle} ,\, {\langle}
 1 ,\, 4 {\rangle} ,\, {\langle} 2 ,\, 3 {\rangle} ,\, {\langle} 2 ,\, 4
 {\rangle} \}}%
\end{tlatex}

Элементы множества можно преобразовывать. Выражение \(\{P(x): x \in S\}\) применяет \(P\) к каждому элементу:
\begin{tla}
  Q: {x * x: x \in 1..3}
  A: {1, 4, 9}
\end{tla}
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} \{ x \.{*} x \.{:} x \.{\in} 1 \.{\dotdot} 3 \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 1 ,\, 4 ,\, 9 \}}%
\end{tlatex}

Полезным также бывает оператор выбора \(CHOOSE~x \in S: P(x)\), который выбирает случайный элемент множества \(S\), удовлетворяющий предикату \(P\). Стоит отметить, что проверщик моделей не будет выполнять полный перебор возможных вариантов выбора, а зафиксирует один.
\begin{tla}
  Q: CHOOSE x \in 1..100: x > 42
  A: 43
\end{tla} 
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} {\CHOOSE} x \.{\in} 1 \.{\dotdot} 100 \.{:} x \.{>} 42}%
\@x{\@s{8.2} A\@s{1.69} \.{:} 43}%
\end{tlatex}

Ожидаемо присутствуют следующие операторы:
\begin{tla}
  Q: {} \in {{}}
  A: TRUE
  Q: {} \notin {{}}
  A: FALSE
  Q: {1,2} \subseteq {1,2,3}
  A: TRUE
  Q: {1,2} \union {3}
  A: {1,2,3}
  Q: {1,2} \intersect {2, 3}
  A: {2}
  Q: {1, 2} \ {2, 3}
  A: {1}
  Q: SUBSET {1,2}
  A: {{}, {1}, {2}, {1,2}}
  Q: UNION {{1}, {2}}
  A: {1, 2}
\end{tla}
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} \{ \} \.{\in} \{ \{ \} \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\TRUE}}%
\@x{\@s{8.2} Q \.{:} \{ \} \.{\notin} \{ \{ \} \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\FALSE}}%
\@x{\@s{8.2} Q \.{:} \{ 1 ,\, 2 \} \.{\subseteq} \{ 1 ,\, 2 ,\, 3 \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\TRUE}}%
\@x{\@s{8.2} Q \.{:} \{ 1 ,\, 2 \} \.{\cup} \{ 3 \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 1 ,\, 2 ,\, 3 \}}%
\@x{\@s{8.2} Q \.{:} \{ 1 ,\, 2 \} \.{\cap} \{ 2 ,\, 3 \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 2 \}}%
\@x{\@s{8.2} Q \.{:} \{ 1 ,\, 2 \} \.{\,\backslash\,} \{ 2 ,\, 3 \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 1 \}}%
\@x{\@s{8.2} Q \.{:} {\SUBSET} \{ 1 ,\, 2 \}}%
 \@x{\@s{8.2} A\@s{1.69} \.{:} \{ \{ \} ,\, \{ 1 \} ,\, \{ 2 \} ,\, \{ 1 ,\, 2
 \} \}}%
\@x{\@s{8.2} Q \.{:} {\UNION} \{ \{ 1 \} ,\, \{ 2 \} \}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 1 ,\, 2 \}}%
\end{tlatex}


\subsection{Логика предикатов}
Комбинация логики высказываний и теории множеств дает логику предикатов, которая позволяет писать утверждения об элементах множества и является базисом разработки на \tlapl. Логика предикатов добавляет кванторы существования (\(\exists\)) и всеобщности (\(\forall\)):

\begin{tla}
  Q: \E x \in {1,2}: x < 0
  A: FALSE
  Q: \A x \in {1,2}: x > 0
  A: TRUE
\end{tla}
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} \E\, x \.{\in} \{ 1 ,\, 2 \} \.{:} x \.{<} 0}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\FALSE}}%
\@x{\@s{8.2} Q \.{:} \A\, x \.{\in} \{ 1 ,\, 2 \} \.{:} x \.{>} 0}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\TRUE}}%
\end{tlatex}

\subsection{Моделирование данных}
Помимо множеств для моделирования данных в \tlapl используются \emph{кортежи} и \emph{структуры}.

Кортежи - упорядоченные последовательности элементов произвольного типа. Основные операторы над ними:
\begin{tla}
  Q: Head(<<0,"A">>)
  A: 0
  Q: Tail(<<0,"A">>)
  A: <<"A">>
  Q: Append(<<0>>, "A")
  A: <<0, "A">>
  Q: <<0>> \o <<"A">> 
  A: <<0, "A">>
  Q: Len(<<0,"A",TRUE>>)
  A: 3
  Q: DOMAIN <<"One", "Two">> 
  A: {1, 2}
\end{tla}
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} Head ( {\langle} 0 ,\,\@w{A} {\rangle} )}%
\@x{\@s{8.2} A\@s{1.69} \.{:} 0}%
\@x{\@s{8.2} Q \.{:} Tail ( {\langle} 0 ,\,\@w{A} {\rangle} )}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\langle}\@w{A} {\rangle}}%
\@x{\@s{8.2} Q \.{:} Append ( {\langle} 0 {\rangle} ,\,\@w{A} )}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\langle} 0 ,\,\@w{A} {\rangle}}%
 \@x{\@s{8.2} Q \.{:} {\langle} 0 {\rangle} \.{\circ} {\langle}\@w{A}
 {\rangle}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\langle} 0 ,\,\@w{A} {\rangle}}%
\@x{\@s{8.2} Q \.{:} Len ( {\langle} 0 ,\,\@w{A} ,\, {\TRUE} {\rangle} )}%
\@x{\@s{8.2} A\@s{1.69} \.{:} 3}%
\@x{\@s{8.2} Q \.{:} {\DOMAIN} {\langle}\@w{One} ,\,\@w{Two} {\rangle}}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 1 ,\, 2 \}}%
\end{tlatex}

Структуры являются ассоциативными массивами и конструируются конутсрукциями вида \([k1 \mapsto v1, k2 \mapsto v2]\):
\begin{tla}
  Q: q == [x |-> {}, y |-> {0, "A"}]
     q.y
  A: {0, "A"}
  Q: DOMAIN q
  A: {"x", "y"}
\end{tla}
\begin{tlatex}
 \@x{\@s{8.2} Q \.{:} q \.{\defeq} [ x \.{\mapsto} \{ \} ,\, y \.{\mapsto} \{
 0 ,\,\@w{A} \} ]}%
\@x{\@s{32.04} q . y}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 0 ,\,\@w{A} \}}%
\@x{\@s{8.2} Q \.{:} {\DOMAIN} q}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{\@w{x} ,\,\@w{y} \}}%
\end{tlatex}

Определен синтаксис генераторов структур:

\begin{tla}
  Q: [x : {1}, y : {0, 1}]
  A: {[x |-> 1, y |-> 0], [x |-> 1, y |-> 1]}
\end{tla}
\begin{tlatex}
\@x{\@s{8.2} Q \.{:} [ x \.{:} \{ 1 \} ,\, y \.{:} \{ 0 ,\, 1 \} ]}%
 \@x{\@s{8.2} A\@s{1.69} \.{:} \{ [ x \.{\mapsto} 1 ,\, y \.{\mapsto} 0 ] ,\,
 [ x \.{\mapsto} 1 ,\, y \.{\mapsto} 1 ] \}}%
\end{tlatex}


\subsection{Операторы и функции}
Для манипуляции данными используются \emph{операторы} и \emph{функции}.

Операторы \tlapl похожи на функции в обычных языках программирования:

\begin{tla}
  Q: IsPrime(x) == x > 1 /\ ~\E d \in 2..x-1: x % d = 0
     IsPrime(37)
  A: TRUE
\end{tla}
\begin{tlatex}
 \@x{\@s{8.2} Q \.{:} IsPrime ( x ) \.{\defeq} x \.{>} 1 \.{\land} {\lnot}
 \E\, d \.{\in} 2 \.{\dotdot} x \.{-} 1 \.{:} x \.{\%} d \.{=} 0}%
\@x{\@s{32.04} IsPrime ( 37 )}%
\@x{\@s{8.2} A\@s{1.69} \.{:} {\TRUE}}%
\end{tlatex}

Функции же больше похожи на словари, где ключи лежат в некотором множестве определения, а значения в множестве значений:

\begin{tla}
  Q: Squares[x \in 1..4] == x * x
     Squares[4]
  A: 16
  Q: DOMAIN Squares
  A: {1, 2, 3, 4}
\end{tla}
\begin{tlatex}
 \@x{\@s{8.2} Q \.{:} Squares [ x \.{\in} 1 \.{\dotdot} 4 ] \.{\defeq} x \.{*}
 x}%
\@x{\@s{32.04} Squares [ 4 ]}%
\@x{\@s{8.2} A\@s{1.69} \.{:} 16}%
\@x{\@s{8.2} Q \.{:} {\DOMAIN} Squares}%
\@x{\@s{8.2} A\@s{1.69} \.{:} \{ 1 ,\, 2 ,\, 3 ,\, 4 \}}%
\end{tlatex}

На самом деле кортежи и структуры реализованы поверх функций. В случае кортежей областью определения являются натуральные чилса.

\subsection{PlusCal}
Для удобства разработчиков был создан язык PlusCal, код которого пишется в многострочных комментариях и транспилируется в \tlapl. Язык похож на C и предоставляет привычные выражения контроля, такие как \emph{while}, \emph{if-then-else}, \emph{goto}. Полезено выражение \(with~x \in S\), которое позволяет указать проверщику моделей, что нужно перебрать все возможные значения \(x\) из множества \(S\).

Пример типичного кода на PlusCal:
\begin{ppcal}
  --algorithm counter
  variables x = 0
  begin
    while x < 5 do
      with inc \in {1, 2} do
        x := x + inc
      end with;
    end while;
  end algorithm; 
\end{ppcal}
\begin{tlatex}
\@x{\@s{8.2} {\p@mmalgorithm} counter}%
\@x{\@s{8.2} {\p@variables} x \.{=} 0}%
\@x{\@s{8.2} {\p@begin}}%
\@x{\@s{16.4} {\p@while} x \.{<} 5 {\p@do}}%
\@x{\@s{24.59} {\p@with} inc \.{\in} \{ 1 ,\, 2 \} {\p@do}}%
\@x{\@s{32.8} x \.{:=} x \.{+} inc}%
\@x{\@s{24.59} {\p@end} {\p@with} {\p@semicolon}}%
\@x{\@s{16.4} {\p@end} {\p@while} {\p@semicolon}}%
\@x{\@s{8.2} {\p@end} {\p@algorithm} {\p@semicolon}}%
\end{tlatex}

\subsection{Темпоральная логика}
Выше уже упоминались операторы темпоральной логики. Они позволяют нам определять свойства \emph{живости (анг. liveness)}, которые описывают, что же должно обязательно происходить в нашей системе со временем.

Попробуем запустить проверку примера выше на соответствие различным темпоральным свойствам и посмотрим на результат:

\begin{itemize}
  \item 
    \begin{tla} 
      [](x > 0)
    \end{tla}
\begin{tlatex}
\@x{\@s{24.59} {\Box} ( x \.{>} 0 )}%
\end{tlatex}
: \(x\) всегда больше нуля. Успех проверки.
  \item
    \begin{tla}
      <>(x = 5)
    \end{tla}
\begin{tlatex}
\@x{\@s{24.59} {\Diamond} ( x \.{=} 5 )}%
\end{tlatex}
: \(x\) обязательно будет равен 5. Поскольку наш счетчик уменьшается или на 1, или на 2, проверщик находит исполнение, в котором свойство не выполняется: \(0,2,4,6\). Свойство не выполняется.
  \item
    \begin{tla}
      (x = 0) ~> (x > 3)
    \end{tla}
\begin{tlatex}
\@x{\@s{24.59} ( x \.{=} 0 ) \.{\leadsto} ( x \.{>} 3 )}%
\end{tlatex}
: если значение \(x\) было 0, то обязательно будет больше 3. Успех проверки.
\end{itemize}

Как видно, знания базовых элементов математики вроде теории множеств почти достаточно для использования \tlapl. Новым для разработчиков может стать формализм темпоральной логики, однако и он прост в изучении, поскольку строится на интуитивном понимании событийности. Также язык предоставляет привычные разработчикам управляющие конструкции. Основываясь на сказанном, язык спецификаций \tlapl составит основу разрабатываемой методики.


\chapter{Методика}
Foo bar

\section{Языки и нотации}

\section{Уточнение требований}

\section{Шаблоны}

\subsection{Алгоритм}

\subsection{Машина состояний}

\section{Примеры}

\subsection{Денежный перевод}

\subsection{Светофоры}

\section{Анализ применимости}

\subsection{Стоимость}

\subsection{Достоинства}

\subsection{Ограничения}

\chapter{Доработка инструментов \tlapl}

\section{Подсветка синтаксиса}

\section{Neovim плагин}

\chapter{Выводы}

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}

